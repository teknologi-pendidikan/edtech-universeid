<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Journal Metadata Lookup</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 40px;
      max-width: 1000px;
      background-color: #fff;
      color: #000;
      transition: background-color 0.3s, color 0.3s;
    }

    body.dark {
      background-color: #121212;
      color: #eee;
    }

    input, button, textarea, select {
      font-size: 16px;
      padding: 6px;
    }

    textarea {
      width: 100%;
      height: 100px;
      margin-top: 5px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }

    th, td {
      border: 1px solid #aaa;
      padding: 6px;
      text-align: left;
      font-size: 14px;
    }

    th {
      background-color: #eee;
    }

    body.dark th {
      background-color: #333;
    }

    .controls {
      margin-bottom: 20px;
    }

    .footer {
      margin-top: 40px;
      font-size: 13px;
      color: #777;
    }

    .footer button {
      margin-top: 10px;
    }

    @media print {
      button, .controls, .footer {
        display: none !important;
      }

      body {
        background: #fff !important;
        color: #000 !important;
      }

      table {
        page-break-inside: avoid;
      }
    }
  </style>
</head>
<body>
  <h2>Journal Metadata Lookup</h2>
  <div class="controls">
    <label><input type="radio" name="mode" value="single" checked onchange="switchMode()"> Single ISSN</label>
    <label><input type="radio" name="mode" value="bulk" onchange="switchMode()"> Bulk ISSNs</label>
    <br><br>
    <div id="input-area">
      <input type="text" id="issn" placeholder="e.g. 1234-5678" onkeypress="handleKey(event)">
    </div>
    <br>
    <button onclick="lookup()">Lookup</button>
    <button onclick="copyAllResults()">Copy All Results</button>
    <button onclick="exportCSV()">Export CSV</button>
    <button onclick="window.print()">Print</button>
    <button onclick="toggleDarkMode()">Toggle Dark Mode</button>
  </div>

  <div id="status"></div>
  <div id="result"></div>

  <div class="footer">
    <p>Note: Data is cached using localStorage for performance.</p>
    <button onclick="clearCache()">Clear Local Cache</button>
  </div>

  <script>
    let isBulk = false;

    function switchMode() {
      isBulk = document.querySelector('input[name="mode"]:checked').value === "bulk";
      const area = document.getElementById("input-area");
      area.innerHTML = isBulk ?
        '<textarea id="issn" placeholder="Enter one ISSN per line"></textarea>' :
        '<input type="text" id="issn" placeholder="e.g. 1234-5678" onkeypress="handleKey(event)">';
    }

    function handleKey(e) {
      if (e.key === "Enter") lookup();
    }

    function toggleDarkMode() {
      document.body.classList.toggle("dark");
    }

    function clearCache() {
      localStorage.removeItem("journalCache");
      alert("Local cache cleared.");
    }

    function formatISSN(raw) {
      return raw.trim().replace(/[^0-9X]/gi, "").replace(/^(.{4})(.{4})$/, "$1-$2");
    }

    function getCache() {
      return JSON.parse(localStorage.getItem("journalCache") || "{}");
    }

    function saveCache(cache) {
      localStorage.setItem("journalCache", JSON.stringify(cache));
    }

    async function lookup() {
      const input = document.getElementById("issn").value.trim();
      const status = document.getElementById("status");
      const resultDiv = document.getElementById("result");
      resultDiv.innerHTML = "";
      status.innerText = "";

      const issns = isBulk ? input.split("\n").map(formatISSN).filter(Boolean) : [formatISSN(input)];
      const cache = getCache();
      const allResults = [];

      for (const issn of issns) {
        status.innerText = `🔍 Looking up: ${issn}`;
        if (cache[issn]) {
          allResults.push([issn, { ...cache[issn], _fromCache: true }]);
          continue;
        }

        try {
          const [oa, cr, dj] = await Promise.all([
            fetch(`https://api.openalex.org/sources/issn:${issn}`),
            fetch(`https://api.crossref.org/journals/${issn}`),
            fetch(`https://doaj.org/api/v4/search/journals/issn:${issn}?page=1&pageSize=1`)
          ]);

          const openalex = oa.ok ? await oa.json() : {};
          const crossref = cr.ok ? await cr.json() : {};
          const doaj = dj.ok ? await dj.json() : {};

          const bib = doaj?.results?.[0]?.bibjson || {};
          const crossData = crossref?.message || {};
          const publisherName = bib.publisher?.name || openalex.host_organization_name || crossData.publisher || "";

          let rorName = "", rorId = "";
          if (publisherName) {
            try {
              const rorRes = await fetch(`https://api.ror.org/organizations?query=${encodeURIComponent(publisherName)}`);
              const rorData = await rorRes.json();
              if (rorData?.items?.length > 0) {
                const ror = rorData.items[0];
                rorName = ror.name || "";
                rorId = ror.id || "";
              }
            } catch {}
          }

          const result = {
            "Source": [doaj?.results?.length > 0 ? "DOAJ" : "", openalex?.id ? "OpenAlex" : "", crossData?.ISSN ? "Crossref" : ""].filter(Boolean).join(" + ") || "Not Found",
            "E-ISSN": issn,
            "P-ISSN": bib.pissn || openalex.issn?.find(x => x !== issn) || crossData.ISSN?.find(x => x !== issn) || "Data not found",
            "Title": bib.title || openalex.display_name || crossData.title || "Data not found",
            "Publisher": publisherName || "Data not found",
            "Publisher Country": bib.publisher?.country || openalex.country_code || "Data not found",
            "ROR Name": rorName || "Data not found",
            "ROR ID": rorId || "Data not found",
            "URL": bib.ref?.journal || openalex.homepage_url || crossData.URL || "Data not found",
            "License": bib.license?.[0]?.type || "Data not found",
            "License URL": bib.license?.[0]?.url || "Data not found",
            "Language": (bib.language || []).join(", ") || "Data not found",
            "APC": bib.apc?.has_apc ? "Yes" : (openalex.apc_prices?.length > 0 ? "Yes" : "No"),
            "APC Amount": bib.apc?.max?.[0]?.price || openalex.apc_prices?.[0]?.price || "Data not found",
            "APC Currency": bib.apc?.max?.[0]?.currency || openalex.apc_prices?.[0]?.currency || "Data not found",
            "Subjects": (bib.subject || []).map(s => `${s.term} (${s.scheme})`).join("; ") || "Data not found",
            "Keywords": (bib.keywords || []).join(", ") || "Data not found",
            "Review Process": Array.isArray(bib.editorial?.review_process) ? bib.editorial.review_process.join(", ") : "Data not found",
            "Publication Time (weeks)": bib.publication_time_weeks || "Data not found",
            "OA Start Year": bib.oa_start || "Data not found",
            "BOAI Compliant": bib.boai ? "Yes" : (openalex.is_oa ? "Yes" : "No"),
            "Uses DOI": (bib.pid_scheme?.has_pid_scheme && bib.pid_scheme.scheme?.includes("DOI")) || openalex.works_count > 0 || crossData["doi-prefixes"] ? "Yes" : "No",
            "DOI Prefix": crossData["doi-prefixes"]?.[0]?.prefix || "Data not found",
            "Crossref Member ID": crossData.member || "Data not found",
            "Works Count": openalex.works_count || "Data not found",
            "Cited By Count": openalex.cited_by_count || "Data not found",
            "h-index": openalex.summary_stats?.h_index || "Data not found",
            "Topics": (openalex.topics || []).slice(0, 5).map(t => t.display_name).join("; ") || "Data not found"
          };

          allResults.push([issn, result]);
          cache[issn] = result;
          saveCache(cache);
        } catch (err) {
          console.error(err);
          status.innerText = `❌ Error on ${issn}`;
        }
      }

      resultDiv.innerHTML = allResults.map(([issn, res]) => {
        const id = `table-${issn}`;
        return `<h4>${issn}${res._fromCache ? " (cached)" : ""}</h4>` +
          makeTable(res, id);
      }).join("<hr/>");

      status.innerText = "✅ Lookup complete.";
    }

    function makeTable(data, id = "") {
      let html = `<table id="${id}"><thead><tr><th>Field</th><th>Value</th></tr></thead><tbody>`;
      for (let key in data) {
        if (key === "_fromCache") continue;
        html += `<tr><td>${key}</td><td>${data[key]}</td></tr>`;
      }
      html += "</tbody></table>";
      return html;
    }

    function copyAllResults() {
      const allTables = document.querySelectorAll("table");
      const rows = Array.from(allTables).map(table => {
        return Array.from(table.querySelectorAll("tbody tr")).map(row =>
          row.cells[1].innerText.replace(/\n/g, " ").trim()
        ).join("\t");
      });
      const finalText = rows.join("\n");
      navigator.clipboard.writeText(finalText).then(() => {
        alert("All results copied (transposed, no headers)");
      });
    }

    function exportCSV() {
      const tables = document.querySelectorAll("table");
      const csv = [];

      tables.forEach(table => {
        const rows = Array.from(table.querySelectorAll("tbody tr"));
        const values = rows.map(row => `"${row.cells[1].innerText.replace(/\n/g, " ").trim()}"`);
        csv.push(values.join(","));
      });

      const blob = new Blob([csv.join("\n")], { type: "text/csv" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "journal_metadata.csv";
      a.click();
    }
  </script>
</body>
</html>
